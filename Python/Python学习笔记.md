Python第一周学习笔记

IDLE分为交互模式和编辑模式

1、标点符号为英文符号

2、缩进正确

3、函数拼写正确

函数名   dir（—builtins—）

变量  变量名由字母、数字和下划线构成，但不能以数字打头

1、给变量赋值    x=...

2、访问变量     运用print函数   print（x）

变量命名规范

（1）不要以数字开头

（2）不要使用python中的固定的单词    ——否则 单词原作用失效

（3）两个单词要使用下划线连接

（4）要使用英文单词，不建议使用中文或拼音

x=y=3   print（x，y） ——3，3

x，y=y，x        作用为x与y的值进行互换

字符串

Single quotes   为单引号将文本包含起来

Double quotes  为双引号将文本包含起来

在文本中不可避免地运用单（双）引号时可以用双（单）引号将文本括起来

转义字符

以反斜杠开头紧接着另一个字符构成的特殊的含义

原始字符串

       \ \——反斜杠                    \b退格符
    
           \ '单引号                           \n换行
    
          \ "双引号                            \t水平制表符
    
            \ a响铃                            \v垂直制表符
    
            \r回车符                          \f换页符
    
            \xhh 为十六进制数          \ooo为八进制数

r  "字符串"表示原始字符串

\不能放在字符串末尾    表示事情还没有结束

Triple  quoted  三个引号  前呼后应    成对存在

不需要使用\即可换行

520   和   '520'

520+1314=1834

'520'+'1314'——'5201314'

print（'5201314'*3000）——打印3000次'5201314'  

temp =input("文本")  用于与进行互动的文本

int（）将数据转换为整型

if条件:

            如果条件为真，执行这里的语句

else：

             如果条件为假，执行这里的语句

判断符号:   <、<=、>、>=、==、！= 、is、is not(判断两边的id是否相等)

成立则Ture，不成立则False

条件语句的嵌套:

if  条件:

else:

         if条件:
    
         else:

python用缩进区分不同层级的语句

while循环语句   counts=3

while条件：counts>0：

如果条件为真(Ture)执行这里的语句——循环体

调整变量：counts=counts-1

相同层级——相同缩进

break语句——跳出一层循环体

import   引入、、、模块

import  random

rondom.randint(a,b)表示获取（a，b）之间的随机整数           

种子

random.getstate(x)

random.setstate(x)

数字类型：

1、整型              2、浮点型            3、负数

除法以小数的形式存在

浮点数的存储方式为IEE法

精确计算浮点数：

1、引入decimal模块

2、decimal.Decimal('   ')实例化一个对象

3、进行计算

E计法

0.00005——5e-5

复数

1+2j  1为实部    2为虚部

x.real——实部            x.imag——虚部

操作符

x//y（地板除）——取比目标结果小的最大整数

x%y——取余数

divmod（3，2）——（1，1）

求出3除以2的商和余数

abs（x）——取绝对值

若x为复数则为模     |1+2j|=根号5

int（3.14）=3

float（520）=520.0

complex（"1+2j")不能有空格

c.conjugate（）——返回c的共轭复数

pow(x,y)或者x**y计算x的y次方

pow（x，y，2）对x的y次方再进行求余的运算

布尔类型

bool（' '）判断真假

字符串只有空字符串为Flase，其他都为Ture

0假  1真

Flase的对象：

1、None和Flase

2、值为0的数字类型:0,0.0,0j,Decimal(0),Fraction(0,1)—分子为0分母为1的有理数

3、空的序列和集合'  ',(  ),[  ],{  },set(  ),range(0)

逻辑运算符

1、A and B  A,B同时成立，则成立

2、A  or  B  A,B有一者成立，则成立

3、 not A        非A

短路逻辑和运算优先级

and or遵从短路逻辑

从左往右，只有当第一个操作符的值无法确定逻辑运算的结果时，才对第二个操作符进行求值。

例如3and4，3为真，and两边为真才真，对4进行求值

运算符优先级

![](https://cdn.jsdelivr.net/gh/1944195627wb/images@main/Python/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20002116.png)

解决问题的思路

1、流程图

2、思维导图

Python第二周学习笔记

**分支与循环（1）**

分支结构

if语句

1、判断一个条件，如果这个条件成立，就执行其包含的某条语句或某个代码块（通过代码块的缩进相同）

if    condition:

           statement（s）

2、判断一个条件:

如果条件成立，就执行其包含的某条语句或某个代码块

如果条件不成立，就执行另外的某条语句或某个代码块

if  condition:

        statement（s）

else:

        statement（s）

3、判断多个条件，如果第一个条件不成立，则继续判断第二个条件，如果第二个条件不成立，接着判断第三个条件......

if  condition1:

        statements(s)

elif  condition2:

         statement(s)

elif   condition3:

         statement(s)

、、、

4、在第三种的情况下添加一个else，表示上面所有的条件均不成立的情况下，执行某条语句或某个代码块

if  condition1:

             statements(s)

elif  condition2:

              statement(s)

elif   condition3:

                statement(s)

、、、 

else:

               statement(s)

**分支与循环（2）**

条件表达式

5、条件成立时执行的语句if  condition  else 条件不成立时执行的语句

a=3

b=5

if  a<b:

      small=a

else:

      small=b

转化为

small=a   if  a<b else b

分支结构的嵌套

if   condition:

        statement(s)

else:

        if  condition:
    
                   statement(s)
    
        else:
    
                    statement(s)

**循环与分支（3）**

循环结构

while循环

while  condition:

           statement(s)

break语句——跳出一层循环体，break语句后面的语句将不会被执行

**分支和循环（4）**

continue语句——结束这次循环，回到到循环的开头

![](https://cdn.jsdelivr.net/gh/1944195627wb/images@main/Python/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20002702.png)

else 语句——当循环的条件不再为真时，执行else语句里的内容 

break语句与else语句连用:若循环次数全部执行完则会执行else语句，若因为break语句而跳出循环时，则不会执行else语句

循环结构的嵌套

while condition:

          statement(s)
    
              while  condition:
    
                        statement(s)

无论是break语句还是continue语句，只能作用于一层循环体

**分支与循环（5）**

for  变量 in 可迭代对象:

           statement(s)

for  each in"FishC"

            print(each)

range(stop)——生成一个由0开始到stop之间的整数序列（不包含stop）

range(start,stop)——生成一个由start开始到stop之间的整数序列

range(start,stop,step)——生成一个由start开始跨步为step到stop之间的整数序列

s计算1至10000

sum=0

for   i   in  range(1,10001)

         sum += i

素数的寻找

for n in range(2,10)

       for  x  in  range(2,n)
    
              if    n%x  == 0:
    
                            print(n,"=",x,"*",n//x)
    
                            break
    
             else:
    
                print(n,"是一个素数")
    
            **c语言与python输出函数的区别**

c语言是跟着以上输出的对象后面继续输出

Python每次输出都是下一行输出，输出完一行之后的print("\n")都是一个隔行

C语言代码:

#include<stdio.h>
int main()
{
	int n,i=1;
	scanf("%d",&n);
	while(i<=n)
	{
		while(i<=n)
		{
			printf("@");
			i++;
		}
		printf("\n");
		i=1;
		n-=1;

}

return 0;

}

python代码:

N = int(input("请输入一个三角形的层数:"))
s = str()
while N:
        s = N*"@"
        print(s)
    N -= 1

**列表（1）**

创建列表:（1）中括号（2）不同元素之间用逗号隔开（3）可以容纳不同类型的元素

for循环按序列访问每个元素：for each in 列表名

访问其中一个元素:下标索引的方法

(1)若访问前部分的元素，可以使用自然数索引，第一个元素为0开始，依次递增。

(2)若访问元素数量较大的的列表中后面的元素，可以使用负数，倒数第一个元素序号为-1，以次递减。

列表切片

(1)在切片时，索引[a:b]的切取范围是a<=X<b,例如arr[0:3]索引的元素为第一个，第二个和第三个。

(2)在切片时，冒号作业的值可以不填，不填的时候则代表一取到底。

(3)在切片时arr[0:6:2]表示第一个元素开始以2为跨度值索引到第六个元素(arr[::2]表示为以2为跨度值从第一个元素到最后一个元素索引)

小技巧:倒序输出列表print(::-1)

**列表（2）**

列表的方法

增:新的内容在原本内容的后面

1、增加一个元素： 列表名.append(增的元素)

2、增加多个元素：  列表名.extend(可迭代对象)——可迭代对象：数组等等

3、切片方法：列表名[len(数组名): ]=[添加元素（可一个或多个）]

4、任意位置添加元素：列表名.insert(元素插入位置,插入元素)

删:

1、删除指定元素：列表名.remove(元素)

注意：

（1）如果列表中存在多个匹配的元素，那么只会删除第一个。

（2）如果指定的元素不存在，那么程序会报错。

2、删除某个位置元素：列表名.pop(删除元素位置)

3、清空所有元素：列表名.clear( )

**列表（3）**

改:

1、改一个元素：列表名[被改元素位置]=所改列表元素

2、改多个元素：切片——列表名[所改多个元素的范围]=可迭代对象

3、改指定元素：列表名[列表名.index(指定元素)]=所改元素——注意为第一个元素位置被改

数字列表排序：

1、从小到大：列表名.sort( )

 2、从大到小：先执行从小到大，后 列表名.reverse( )——原地反转列表中的元素

3、从大到小：列表名.sort(reverse=Ture)

查:

1、查找某个列表元素的数量：列表名.count(查找元素)

2、查找某个列表元素的位置：列表名.index(查找元素，起始位置，结束位置)

注意：

（1）若有多个元素，则返回值为第一个列表位置

（2）起始位置和结束位置可省略

列表复制：

1、粘贴列表名=复制列表名.copy( )

2、切片——粘贴列表名=复制列表名[ : ]

Python第三周学习笔记**

**列表（4）**

列表的加法和乘法

列表的加法规则：相加的两个列表的元素共同组成一个新的列表

列表的乘法规则：重复列表内的所有元素若干次

列表的嵌套

[[列表元素],[列表元素],[列表元素]...]

访问嵌套列表

for i in 列表名:

       for each in i:
    
                  print(each)

访问某个元素列表名[所在行]  [所在列]

两个容易不同的列表(存储方式不一样)

(1)for i in range(3):

            A[i]=[0]*3 

![](https://cdn.jsdelivr.net/gh/1944195627wb/images@main/Python/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20003320.png)

(2)B=[ [ 0 ]  * 3]  * 3

![](https://cdn.jsdelivr.net/gh/1944195627wb/images@main/Python/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20003328.png)

 is 运算符（同一性运算符）:用于检验两个变量是否指向同一个对象的一个运算符

**列表（5）**

列表赋值给变量

当赋值运算发生的时候，并不是将数据放置到变量中，而是将变量与数据进行挂钩——引用，所以赋值时改变原变量，赋值变量也改变——引用

若创建两个独立的列表，则需要进行拷贝

1、浅拷贝——赋值时改变原列表元素，新列表也改变，子对象只是进行了引用

（1）新列表=原列表.copy( )

（2）新列表=原列表[ : ] 

![](https://cdn.jsdelivr.net/gh/1944195627wb/images@main/Python/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20003604.png)

2、深拷贝——将原对象拷贝的同时，也将所有引用的子对象一并进行了拷贝，原列表改变子元素时，新列表不会进行改变

import  copy

新列表=copy.deepcopy(原列表)——多维列表

**列表（6）**

列表推导式——运行更快，只限于列表

len( )——获取列表的长度

新列表=[表达式 for target in 对象]

相当于for target  in 对象:

                     表达式

ord(对象)——将字符串转化为对应的编码

获取二维列表中的数据

新列表=[row() for row in 列表]

**列表（7）**

可以通过列表推导式获得新的列表

S=[[0]*3 for i range(3)]

扩充条件：

列表=[expression for target in iterable if condition]

先执行for语句        再执行if语句          再执行表达式

列表推导式的嵌套

[expression  for target1 in iterable1 if condition1

                       for target2 in iterable2 if condition2
    
                       、、、
    
                       for targetN in iterableN if conditionN]

外层循环在前面，内层循环在后面

_可以充当无关紧要的变量名

保持简洁原则

**元组**

元组=(元素)——小括号可去

性质：元组中的元素可通过下标索引，内容不可变，支持切片操作，支持加号和乘号运算

只支持查

1、元组.count(查找元素)——查找元素数量

2、元组.index(查找元素)——查找元素下标

元组的嵌套

新元组=原元组1,原元组2

元组的括号必要性

生成一个元素的元组——元组=(元素,)

打包和解包——适合所有序列

打包——新元组=(原元组1，原元组2，原元组3、、、)

解包——新元组1，新元组2，新元组3、、、=原元组——数量一致

若不一致，可用*新元组，那么后面的元组则全部赋值给此新元组

多重赋值

x,y=赋值,赋值

print函数用法——print(""语句%d,%d",%(对象，对象))

元组中的元素是不可变的但是若元组中存放的是可变的列表，那么列表中的内容则是可变的

**字符串（1）**

回文数——正数与反数是一样的数字例如12321

字符串属于序列，可以用切片的方法

字符串的诸多方法

大小写转化

1.将首字符为大写，其余字符变为小写——字符串名.capitalize()——生成字符新串，不是改变原字符串

2.将所有字符都变小写的字符串——字符串名.casefold()——支持所有语言字符

3.将所有单词的首字母变大写的字符串——字符串名.title()

4.将所有字母的大小写翻转——字符串名.swapcase()

5.将所有字符都变成大写——字符串名.upper()

6.将所有字符都变成小写——字符串名.lower()——只支持英文字符改变

左中右对齐

1、居中对齐——字符串名.center(字符串长度,填充内容)

2、左对齐——字符串名.ljust(字符串长度,填充内容)

3、右对齐——字符串名.rjust(字符串长度,填充内容)

4、左边填充0——字符串名.zfill(字符串长度)——处理数据报表

**字符串（2）**

1、查找某个字符在字符串中的个数——字符串名.count(查找元素,起始位置，结束位置)

2、查找某个字符在字符串中的索引值（从左往右找）——字符串名.find(查找元素)

3、查找某个字符在字符串中的索引值（从右往左找）——字符串名.rfind(查找元素)

4、列表名.index.()和列表名.rindex.()与find和rfind的用法差不多，但在查找不存在的元素时，find返回值为-1，而index则会报错

替换

1、将tab键换成空格符——字符串.expandtabs(空格数)

2、将指定内容换成新内容——字符串.replace（指定内容，新内容，次数（不说明则全部））

3、将字符串的内容按指定对应表格替换——字符串.translate(table)

table指的是对应关系——创建对应关系需要table=str.maketrans(内容，对应内容，忽略内容)

**字符串（3）**

判断

1、判断指定内容是否出现在参数指定的字符串起始位置——参数.startwith(指定内容，起始位置，结束位置)

2、判断指定内容是否出现在参数指定的字符串结束位置——参数.endwith(指定内容，起始位置，结束位置（不包括结束字符）)——指定内容可以用元组的形式,不只一个

3、判断字符串中所有单词的首字母是否为大写——字符串.istitle()

4、判断字符串中所有字母是否都为大写——字符串.isupper()

5、判断字符串中所有字母是否都为小写——字符串.islower()

6、判断字符串中是否都为字母构成(包括空格)——字符串.isalpha()

7、判断字符串中是否都为空白（包括换行）——字符串.isspace()

8、判断字符串中是否都可以打印（转义字符不可打印）——字符串.isprintable()

9、isdecimal()、isdigit()、isnumeric()判断是否都为数字——区别：

（1）isdecimal：是否为十进制数字符，包括Unicode数字、双字节全角数字，不包括罗马数字、汉字数字、小数；

（2）isdigit：是否为数字字符，包括Unicode数字，单字节数字，双字节全角数字，不包括汉字数字，罗马数字、小数；

（3）isnumeric：是否所有字符均为数值字符，包括Unicode数字、双字节全角数字、罗马数字、汉字数字，不包括小数。

10、isalnum()——只要isalpha(),isdecimal(),isdigit(),isnumeric()中一个对，那么就返回Ture

11、用于判断一个字符串是否是一个合法的标识符(不能有空格，不能以数字开头、、、)——isdentifier()

12、判断是否为关键词

（1）引进keyword模块——import keyword

（2）keyword.iskeyword(字符串)

字符串（4）

截取

1、去除左侧内容——字符串.lstrip(去除指定内容（对应长度相同）)——若无指定内容则为去除空白

2、去除右侧内容——字符串.rstrip(去除指定内容)

3、去除两边内容——字符串.strip(去除指定内容)

4、去除指定前缀——字符串.removeprefix(前缀)

5、去除指定后缀——字符串.removesuffix(后缀)

拆分和拼接

1、拆分（从左到右）——字符串.partition(分割符)——分成三块（分割符左边，分割符，分隔符右边）

2、拆分（从右到左）——字符串.rpartition(分割符)

3、切分（从左往右）——字符串.split(分割符，次数)——按分隔符分（不存在分割符号）（没有参数则以空白为分割符）

4、切分（从右往左）——字符串.rsplit(分割符，次数)——按分隔符分（不存在分割符号）

5、按换行符切分——字符串.splitlines(Ture/False)参数表示是否将换行符分在符号前面的字符串中

6、拼接——拼接字符.join(字符串1,字符串2,字符串3、、、)比加号进行拼接的效率更高

**字符串（5）**

格式化字符串

将参数所对应的数据传入到对应字符串中——字符串{位置1或关键词参数}{位置2}{位置N}.format元组或者关键词参数和对应内容

输入大括号可以用format.({})或者字符串中{{}}

对齐的方式

![](https://cdn.jsdelivr.net/gh/1944195627wb/images@main/Python/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20003757.png)

"{位置或关键字索引:(填充字符)格式化选项宽度}".format(内容)——加0那么自动填充0具有感知正负号效果

**字符串（6）**

![](https://cdn.jsdelivr.net/gh/1944195627wb/images@main/Python/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20003855.png)

,用来作为千位的分割符

.的用法

![](https://cdn.jsdelivr.net/gh/1944195627wb/images@main/Python/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20004038.png)

Tpye类型

整数

![](https://cdn.jsdelivr.net/gh/1944195627wb/images@main/Python/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20004121.png)

若加#，那么可以显示格式类型

浮点数

![](https://cdn.jsdelivr.net/gh/1944195627wb/images@main/Python/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20004222.png)

f-字符串3.6版本以上

更为简洁

f"{-520:010}"——'-000000520'

Python第四、五周学习笔记**

序列（1）

1、都可以通过索引的方法寻找元素

2、第一个元素的索引值都是0

3、都可以通过切片的方法获取一个范围

4、都有很多共同的运算符，+    *

可变序列：列表

不可变序列：元组，字符串

对象的基本属性：1.唯一标志   2.类型  3.值

列表——唯一标志随着创建时唯一确定，每个对象都不一样，不会被修改，元组则会发生改变

id(对象)——返回代表对象的唯一标志的整数值

is和is not用于判断两个对象的id是否相等

in和not in用于判断两个对象是否包含和被包含的关系

del用于删除一个或多个指定的对象或可变对象中的指定元素

del 对象[::2]以2为步伐从头到尾进行删除，切片则不行

注意del 序列[a:b]删除为下标索引值为从a<=x<b的元素

**序列（2）**

列表、元组和字符串相互转化的函数

1、转化成列表——list(可迭代对象)

2、转化成元组——tuple(可迭代对象)

3、转化成字符串——str(可迭代对象)

min()&max()

1、对比可迭代对象中元素比较元素的编码值并且返回最大或最小的元素

2、对比直接传入的参数的大写返回最大值或最小值

编码值大写字母在小写字母之前

min()&max()含两个参数第一个为可迭代对象，第二个为default=报错时显示的内容

len()&sum()

len()——计算可迭代对象的长度

sum(可迭代对象，start)——计算可迭代对象或者传入参数的和    注意：start

为从start开始计算

sorted()&reversed()

sorted()——给可迭代对象进行排序

1、关键词reverse决定是否翻转

2、关键词key决定函数类型的返回结果再进行比较

sorted()与sort()的区别是sorted返回的是一个全新的列表sort是改变原来的列表且只能处理列表

reversed()——将可迭代对象翻转

list(reversed(可迭代对象))——返回为列表

**序列（3）**

all()&any()

all()——判断可迭代对象中所有元素的值是否为真

any()——判断可迭代对象c中是否存在某个元素的值为真

enumerate(start用来确定开始的值)——用于返回一个枚举对象，将可迭代对象中的每个元素及从0开始的序号共同构成一个二元组的列表

zip()——用于创建一个聚合多个可迭代对象的迭代器。将作为参数传入的每个可迭代对象的每个元素依次组合成元组，即第i个元组包含来自每个参数的第i个元素。（以最短的为主）

若以最长的为主：

import itertools

itertools.zip_longers()

map(函数，可迭代对象)——根据提供的函数对指定的可迭代对象的每个元素进行运算，并将返回运算结果的迭代器

filter()——根据提供的函数对指定的可迭代对象的每个元素进行运算，并将运算结果为真的元素，以迭代器的形式返回。

迭代器和可迭代对象

可迭代对象可重复使用，迭代器是一次性的

iter(可迭代对象)——可将可迭代对象转化成迭代器

next(可迭代对象，异常警告)——将迭代器中的元素逐个提取出来

**字典**

字典内部的实现是映射类型

结构：参数={键：值，键：值，、、、}    输入键，输出值

参数[不存在的键]=映射的值，则原字典产生新键和值

创建字典

1、参数={键：值，键：值，、、、} 

2、dict(键=值，键=值、、、)注意：键不能用引号

3、dict([键，值],[键，值]、、、)

4、dict({键：值，键：值，、、、} )

5、dict({键:值}键=值)与2一样

6、dict(zip([键1，键2、、、])，[值1，值2、、、])

增——dict.formkeys(键，值)

删——1、pop(键，异常提醒)            2、del 字典[键]

改（值）

1、字典[键]=新值        

 2、字典.update(键：值)或字典.update(键=值)

除——字典.clear()

查：

1、字典[键]

2、get(键，异常警告)

setdefault(键，若没有则新赋的值)

获取字典的键值对的视图对象

items()——获取对视图对象

keys()——获取键视图对象

values()——获取值视图对象

浅拷贝——字典.copy()

len()——获取键值对的数量

in&not in检查键是否在字典内

iter(字典)——将字典转化成迭代器

reversed(字典.键值对)——将键值对进行倒序

嵌套——{键：{键1：值1，键2：值2、、、}}

字典推导式——{表达式for键，值in字典.键值对   条件}

**集合（1）**

1、{元素1，元素2、、}

2、{集合推导式}

3、set(序列或字典)

唯一性，无序性,不可下标索引，支持浅拷贝

检测是否有交集——集合1.isdisjoint(集合2)

检测一个集合1是否为另一个集合2的子集——集合1.issubset(集合2)

检测一个集合1是否为另一个集合2的超集——集合1.issuperset(集合2)

并集：集合1.union(集合2)

交集：集合1.intersection(集合2)

差集：集合1.difference(集合2)——存在于1而不存在于2中的元素

对称差集——集合1.symmetric_difference(集合2)

检测子集：集合1<=集合2

检测真子集：集合1<集合2

检测超集：集合1>=集合2

检测真超集：集合1<=集合2

并集：集合1|集合2

交集：集合1&集合2

差集：集合1-集合2

对称差集：集合1^集合2

**集合（2）**

不可变集合——frozenset()

只支持set集合更改内容

1、集合.update(*others)——使用others参数指定的值来更新集合

2、交集intersection_update(*others)

3、差集difference_update(*others)

4、对称差集symmetric_difference_update(others)

插入某个元素：集合.add(元素)

删除某个元素：

1.remove(elem)抛出异常2.discard(elem)静默处理3.pop()随机删除

清空集合：集合.clear()

可哈希——不可变对象，不可哈希——可变对象

1.hash(对象)

不可哈希不能作为字典的键和集合的元素

**函数（1）**

创建和调用函数

def 函数名(参数1，/，参数2):

      函数体

return语句用于函数的返回值

若没有返回值，则执行所有语句后返回None

**函数（2）**

参数：1、位置参数2、关键字参数3、默认参数4、收集参数

若两种参数混用，位置参数在关键字参数前面

help()——查看函数文档

/左侧默认参数/右侧为关键字参数

**函数（3）**

收集参数——*形参

字典收集形参**形参

解包参数

默认参数——*元组

关键字参数——**字典

**函数（4）**

作用域

 局部变量函数中定义——局部作用域                                                                               

全部变量在函数外定义——全局作用域

在函数中局部变量会覆盖全局变量的值

global语句——改变全局变量而不是局部变量

嵌套函数

内部函数不能直接进行调用，在外部函数内部进行调用

nonlocal语句——使内部函数可以改变外部函数的变量

return 函数

LEGB规则

**函数（5）**

闭包——使函数具有记忆功能

def outer():

          x=0
    
          y=0
    
          def inner(x1,y1):
                             nonlocal x,y
    
                             x+=x1
    
                             y+=y1
    
                             print(f"现在,x={x},y={y}")
    
          return inner

**函数（6）**

函数可以作为参数传递

引入时间模块

装饰器

import time

def time_mater(func):

      def call_func():
    
              start=time.time()
    
              func()
    
               stop=time.time()
    
               print("{stop-start:.2f}")
    
      return call_func

@time_master

def myfunc():

        time.sleep(2)

装饰器调用顺序

从下往上

**函数（7）**

lambda表达式

lambda arg1，arg2，arg3，...argN:expression

相当于

def lambda (arg1,arg2,arg3...)

return expression

**函数（8）**

生成器

yield语句raise 和 assert 都可以用来抛出异常，但它们的用途不同。

raise 语句用于主动抛出异常，你可以使用它来抛出一个指定的异常，或者重新抛出一个捕获到的异常。

而 assert 语句通常用于调试目的，它可以帮助你检查代码中的错误。当你认为某个条件一定为真时，你可以使用 assert 来断言这个条件。如果条件不满足，程序会抛出 AssertionError 异常并中止执行。这样，你就可以快速定位到错误发生的位置。

总之，raise 语句用于主动抛出异常，而 assert 语句用于检查错误。

yield语句

1、不走回头路

2、支持next函数

3、不支持下标索引

生成器表达式和列表推导式区别：列表推导式将所有的数据生产放在列表中，生成器表达式只会一个一个数据生产。

**函数（9）**

递归

必须有个结束条件而且每次递归都接近递归

**函数（10）**

汉诺塔

**函数（11）**

help()查看函数文档

"""文档内容"""

类型注释

def 函数名(形参：类型)->类型

内省

查看类型注释

函数. _ annotations _

查看函数文档

函数._ doc _

**函数（12）**

高阶函数

将可迭代对象中的元素依次传递到含两个参数的函数中，最终返回累积的结果

import funtools

funtools.reduce(函数名,可迭代对象)

lambda表达式也可以充当函数

偏函数

将一个函数的这个多个参数给拆分

funtools.partial(函数，参数为何值)——相当于闭包

@wraps装饰器

Python第六周学习笔记**

**永久储存（1）**

打开文件

创建文件——open(文件名，打开功能)会返回一个文件对象"w"写入带有截断功能

文件对象的各种方法

将字符串写入文件对象中

1、f.write()会返回写入的字符数量

2、f.writelines([字符串1,字符串2,、、、])同时多个字符串写入

f.close()——关闭文件对象才能写入对象中

"r+"更新和读取

f.readable()——测试读取功能

f.writeable()——测试写入功能

for each in f:

print(each)——读取

文件对象内部有文件指针——负责指向文件的当前位置

修改文件指针

f.seek(修改后的文件指针位置)

f.readline()——每次读取一行

f.flush()——将文件对象的缓存数据写入到文件中

f.truncate(pos=None)——将文件对象截取到pos的位置，默认是截取到文件指针当前指定的位置

使用单独的写入模式来打开文件也会进行截断

**永久储存（2）**

路径处理

from pathlib import Path

Path.cwd()——获取当前的工作目录

.is_dir()判断路径是否为文件夹

.is_file()判断路径是否为一个文件

.exists()判断路径是否存在

.name获取路径的最后一个属性

stem获取文件名

suffix获取文件后缀

parent获取父级目录

parents获取逻辑祖先路径构成的序列

支持索引

文件名[0]指向父级目录，[1]减去一级[2]减去两级逐渐递推

parts将路径的各个组件拆分成元组

stat()查询文件或文件夹的信息

.st_size()——尺寸

相对路径和绝对路径

绝对路径是指从根目录开始一级一级地指向最终的文件或者文件夹

相对路径是指以当前目录为基准进行一级一级的目录推导的路径"./doc

resolve()将相对路径转换为绝对路径

iterdir()——获取当前路径下所有子文件和子文件夹

收集文件[x for x in p.iterdir() if x is_file()]

mkdir(parents,exist_ok)创建文件夹

n=p/"文件夹1/文件夹2/、、、"

open()打开文件

rename()——修改名字

replace()替换指定文件或文件夹

rmdir()——删除文件夹

unlink——删除文件

glob()——查找功能

文件夹内有文件必须先删除内部的文件后才能删除文件夹

**永久储存（3）**

with语句和上下文管理器

with open(文件名，打开功能) as变量名 :

          操作文件

with语句能确保文件的正常关闭（即使中间出现错误）

pickle允许将列表、字符串、字典等Python对象保存为文件的形式

import pickle

语句

with open("文件名.pkl","打开功能") as 变量名:

	pickle.dump(语句创建出的对象，变量名)

读取：

  	pickle.load(变量名)——与储存顺序一致

**异常（1）**

(1)语法错误

(2)逻辑错误等等

处理异常

try:

         检测范围

except[expression1[as identifier]]:

except[expression2[as identifier]]:

、、、

        异常处理代码

except(错误1，错误2，错误3、、、)只要出现代码中任意一个错误都会报错

**异常（2）**

try-except-else

else：没有检测到异常的情况下执行else的语句

try-except-finally

无论异常是否发生都会被执行的内容

try:

	检测范围

except [expression[as identifier]]:

	异常处理代码

[except [expression[as identifier]]:

	异常处理代码]*

[else:

	没有触发异常时执行的代码]

finally:

收尾工作执行的代码]

try:

	检测范围

finally:

	收尾工作执行的代码

异常的嵌套

raise语句

raise 语句用于主动抛出异常。你可以使用它来抛出一个指定的异常，或者重新抛出一个捕获到的异常。raise 语句的基本语法格式为：raise [Exception [, args [, traceback]]]。其中，Exception 是异常的类型（例如，NameError），args 是自己提供的异常参数，最后一个参数是可选的，如果存在，是跟踪异常对象1。

下面是一个简单的例子：

```python
try:x = 5 / 0

except ZeroDivisionError:

print("除数不能为零")

raise
```

复制

在这个例子中，我们首先使用 try-except 语句捕获了 ZeroDivisionError 异常，并在 except 块中使用 raise 语句重新抛出了这个异常。

异常链

raise from

assert语句可以进行调试

assert 调试语句

assert 通常用于调试目的，它可以帮助你检查代码中的错误。当你认为某个条件一定为真时，你可以使用 assert 来断言这个条件。如果条件不满足，程序会抛出异常并中止执行。这样，你就可以快速定位到错误发生的位置。

raise 和 assert 都可以用来抛出异常，但它们的用途不同。

raise 语句用于主动抛出异常，你可以使用它来抛出一个指定的异常，或者重新抛出一个捕获到的异常。

而 assert 语句通常用于调试目的，它可以帮助你检查代码中的错误。当你认为某个条件一定为真时，你可以使用 assert 来断言这个条件。如果条件不满足，程序会抛出 AssertionError 异常并中止执行。这样，你就可以快速定位到错误发生的位置。

总之，raise 语句用于主动抛出异常，而 assert 语句用于检查错误。

利用异常实现goto

**类和对象（1）**

对象=属性+方法

需创建一个类再通过类创造实际的对象

class 类:(类名需要大写字母)

      属性特征

def 方法(self):

         执行语句

、、、

self是用于传递给方法的实例对象本身

变量名=类名()

则变量拥有创建类的属性

dir(对象)——可以查看对象的属性和方法

**类和对象（2）**

封装

在创建对象之前通过类将相关的属性和方法打包在一起通过类生成相应的对象

继承

class 子类(父类):

子类中含有父类的属性和方法

子类可以覆盖父类的属性和方法

isinstance()——判断某个对象是否属于某个类

issubclass(子类，父类)——判断一个类是否为某个类的子类

多重继承

class子类(父类1，父类2、、、)

从左到右，只有当父类1中的属性或方法不存在时，则会继承父类2中的属性和方法

组合

class 类:

```python
实例化对象1

实例化对象2

、、、

def say(self):

	self .方法1（绑定）

	self .方法2

	、、、
```

**类和对象（3）**

内省（字典）

实例化对象._ _dict_ _

通过空类实例化对象

class C:

c=C()

c.x=250

**类和对象（4）**

构造函数

_ _ _init_ _ _()

class C:

	def _ _init_ _(self,x,y)
	
		self.x=x
	
		self.y=y

重写

调用未绑定的父类方法

钻石继承会导致父类所调用的方法调用两次

super()——能够在父类中搜索指定的方法

mro()方法解析顺序

**类和对象（5）**

Mix-in

在不改变原有的类的情况下插入方法

多继承的方式

**类和对象（6）**

多态

运算符，函数等在面向不同的对象时所展现出不同的功能

类的多态表现在子承父类时可以将父类的某些属性和方法进行改变

在给函数传递不同的对象时，函数会根据不同的类进行执行不同的方法

鸭子类型

**类和对象（7）**

私有变量

通过某种手段，使得对象中的属性或方法无法被外部所访问

name mangling

self.__x

若需访问则可以实例化对象._类__x

名字改编发生在类实例化对象时，在后期添加时并不会发生

单个下滑线开头的变量

内部使用的变量

单个下划线结尾的变量可以用来代替特定词

添加属性：实例化对象._ _dict_ _['添加属性']=值

动态添加属性

_ _slots_ _=['属性名称1'，'属性名称2、、、']

在_ _slots_ _以外的属性不可添加

继承自父类的_ _slots_ _属性是不会在子类中生效的

存在_ _slots_ _属性但是也存在_ _ _dict_ _属性

**类和对象（8）**

（1）_ _init_ _(self[,...])——当实例化对象被创建时所调用的方法

（2）_ _new_ _(cls[,...])——创建类的实例

（3）_ del_(self[,...])——当最后一个引用实例化对象被销毁时所调用的方法

对象的重生

（1）定义_ _del_ _方法的时候，定义全局变量，将实例化对象进行引用

（2）闭包：在对象销毁之前，调用函数，通过参数传递的形式将self传递出去

**类和对象（9）**

重新定义加法

def _ _add_ _(self,other)

加法运算时是使用第一个参数的方法

_ radd__()方法调用前提

当两个对象相加时，如果左侧的对象和右侧的**对象不同类型**，并且左侧的对象没有定义_ _add_ _()方法，或者其_ _ _add_ _()返回Notlmplemented，那么Python就会去右侧的对象中去查找是否有_ _ _radd_ _()方法的定义。

如果对象相同，则会在父类中查找_ _add_ _()方法

增强赋值运算

def _ _iadd_ _(self,other)

在进行赋值运算将运算结果赋值给对象

**类和对象（10）**

位运算

（1）按位与（&）——只有两者都为1才1

（2）按位或（|）——只要有一者为1就为1

（3）按位非（~）——按位取反

（4）按位异或（^）——如果按位二进制的数字不一样时，就取1

（5）左移（<<）——左侧为对象，右侧为移动的位数（正整数），结果为整数

（6）右移（>>）****

bin()——转换为二进制   0b

优先级：|、^、&、<<、>>、~

math.ulp最低有效位

_ _index_ _(self)

当对象作为索引去用的时候，会调用魔法方法，并将返回值作为索引值

**类和对象（11）**

属性访问

（1）hasattr(对象，属性（以字符串的形式）)——检测是否有这个属性

（2）getattr(对象，属性)——获取属性值

（3）setattr(对象，属性，改变后的值)——改变属性值

（4）delattr(对象，属性)——删除对象的某属性

函数：_ _getattr_ _()先响应方法：_  _ _getattribute_ _()再进行函数

**类和对象（12）**

_ _getitem_ _(self,index)——当对象进行索引操作时

_ _setitem_ _(self,index)——当对象进行切片操作时

支持切片操作

s[2:6]=s[slice(2,6)]

for语句会触发_ _getitem_ _(self,index)

_ _iter_ _(self)——可迭代对象有

_ _next_ _(self)——迭代器有

**类和对象（13）**

_ _contains_ _(self,item)——用于实现成员关系的检测（对应运算符：in和not in）

当对象中没有contains方法时会用iter方法、next方法getitem方法进行补偿

raise StopIteration——取消迭代

_ _bool_ _()布尔测试

如果没有_ _bool_ _方法则会找len()方法如果有则ture，如果无则false

比较运算

![](https://cdn.jsdelivr.net/gh/1944195627wb/images@main/Python/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20004454.png)

如果定义某方法为None，则会异常

**类和对象（14）**

_ _call_ _(self[,args...])——调用函数时调用对象

_ _str_ _(self)——字符串的内置函数：给人看

_ repr_ (self)——添加引号：给程序看——可以访问一个对象中以列表的形式存储多个类

eval()将参数去引号后执行

如果没有str则会寻找repr进行代偿

**类和对象（15）**

![](https://cdn.jsdelivr.net/gh/1944195627wb/images@main/Python/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20004607.png)

class C:

	def _ _init_ _(self):
	
		self._x=250
	
	def getx(self):
	
		return self._x
	
	def setx(self,value):
	
		self._x=value
	
	def delx(self):
	
		del self._x
	
	x=proerty(getx,setx,delx)

只读属性

**类和对象（16）**

类方法

@classmethod装饰器

绑定的是一个类而非实例化对象

静态方法——不需要进行绑定——实例化对象和类都可以调用

@staticmethod装饰器

**类和对象（17）**

描述符

![](https://cdn.jsdelivr.net/gh/1944195627wb/images@main/Python/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20004721.png)

**类和对象（18）**

描述符只能应用于类属性

（1）数据描述符——使用了set方法或delete方法

（2）非数据描述符——只使用了get方法

优先级

![](https://cdn.jsdelivr.net/gh/1944195627wb/images@main/Python/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-17%20004820.png)

__ set_name__(self,name,owner)——获取属性名

**类和对象（18）**

函数与方法

type(对象)——返回为对象的类

串联两个装饰器

@classmethod

@property

能够通过属性访问的形式调用类方法

当多个装饰器修饰方法时，装饰顺序是自下往上

**类和对象（19）**

类装饰器

先调用装饰器函数再进行实例化对象再回来

_ _call_ _(self,*args,**kwargs)——当对象作为函数被调用时会调用此方法

当类进行实例化对象的时候会调用此方法

可以将函数装饰类，也可将类装饰函数，也可以将类装饰类

**类和对象（20）**

type()

（1）判断对象的类

（2）转化类

（3）创造类——类名=type('类名',子类（元组的形式），属性（字典形式）)

fromkeys()——从可迭代对象去出对象

_ _bases_ _——查找类的父类

_ _init_ _subclass__()——在子类继承父类时调用的方法（属性将会被覆盖）

**类和对象（21）**

元类（继承至type）

class 类名(type):

**类和对象（22）**

元类的方法

（1）在定义类的时候可以进行添加属性

（2）对类名的定义规范做限制

（3）修改对象的属性值

（4）限制类实例化时的传参方式

（5）禁止一个类被实例化

（6）只允许实例化一个对象